#include "pds/evgr/MasterFIFOHandler.hh"
#include "pds/evgr/EvrFifoServer.hh"
#include "pds/evgr/EvrTimer.hh"

#include "pds/utility/Mtu.hh"
#include "pds/xtc/EvrDatagram.hh"
#include "pds/collection/Route.hh"
#include "pds/utility/Appliance.hh"
#include "pds/utility/Occurrence.hh"
#include "pds/utility/StreamPorts.hh"
#include "pds/xtc/CDatagram.hh"
#include "pds/xtc/EnableEnv.hh"
#include "pds/utility/Transition.hh"
#include "pds/vmon/VmonEvr.hh"

#include <new>
#include <string.h>
#include <signal.h>
#include <byteswap.h>
#include <stdlib.h>

using namespace Pds;

enum { giMaxNumFifoEvent  = 32 };
enum { giNumL1Buffers     = 32 };

static void _print_L1(const ClockTime& iTriggerCounter,
          const EvrL1Data& evrL1Data)
{
  printf("Trigger counter: %d.%09d, Current Data counter: %d.%09d\n"
   "  Read Index = %d, Write Index = %d\n",
   iTriggerCounter.seconds(),
   iTriggerCounter.nanoseconds(),
   evrL1Data.getCounterRead().seconds(),
   evrL1Data.getCounterRead().nanoseconds(),
   evrL1Data.readIndex(), evrL1Data.writeIndex() );
}

static long long int timeDiff(timespec* end, timespec* start) {
  long long int diff;
  diff =  (end->tv_sec - start->tv_sec) * 1000000000LL;
  diff += end->tv_nsec;
  diff -= start->tv_nsec;
  return diff;
}

static bool evrHasEvent(Evr& er);

/*
 * Signal handler, for processing the incoming event codes, and providing interfaces for
 *   retrieving L1 data from the L1Xmitter object
 * The Master EVR process is indicated by L1Xmitter::enable.  The master is responsible
 * for sending the EvrDatagram to the other segment levels, generating the sw triggers,
 * adding the FIFO data to the L1Accept datagram, and counting events for calibration cycles.
 * All EVR processes configure the
 * EVRs to generate hardware triggers.  The slave EVR processes only need verify that
 * their FIFO data matches the timestamp of the L1Accept generated by the master.
 */
MasterFIFOHandler::MasterFIFOHandler(Evr&       er,
             const Src& src,
             Appliance& app,
             EvrFifoServer& srv,
             unsigned   partition,
             int        iMaxGroup,
                     unsigned   module,
             unsigned   neventnodes,
             bool       randomize,
                                     Task*      task,
                                     VmonEvr&   vmon):
  uFiducialPrev       (0),
  bEnabled            (false),
  _er                 (er),
  _module             (module),
  _app                (app),
  _srv                (srv),
  _done               (new EvrTimer(app)),
  _outlet             (sizeof(EvrDatagram), 0, Ins   (Route::interface())),
  //_dst0               (StreamPorts::event(partition,Level::Segment, 0, 0)),
  _swtrig_out         (Route::interface(), Mtu::Size, 16),
  _swtrig_dst         (StreamPorts::event(partition,Level::Observer)),
  _src                (src),
  _data               (giNumL1Buffers,
           sizeof(EvrDataType)+giMaxNumFifoEvent*sizeof(EventCodeType)),
  _evtCounter         (0),
  _evtStop            (0),
  _iMaxGroup          (iMaxGroup),
  _nnodes             (neventnodes),
  _randomize_nodes    (randomize),
  _validateFiducial   (true),
  _full               (false),
  _vmon               (vmon)
{
  _lSegEvtCounter.resize(1+_iMaxGroup, 0);
  for (int iGroup=0; iGroup <= _iMaxGroup; ++iGroup)
    _ldst.push_back(StreamPorts::event(partition,Level::Segment, iGroup, _module));

  { timespec tmres;
    clock_getres (CLOCK_REALTIME, &tmres);
    printf("CLOCK_REALTIME resolution %u.%09u\n",
           (unsigned)tmres.tv_sec, (unsigned)tmres.tv_nsec);
  }

  timespec tv;
  clock_gettime(CLOCK_REALTIME, &tv);
  srand(tv.tv_nsec);
}

MasterFIFOHandler::~MasterFIFOHandler()
{
  delete _done;
}

InDatagram* MasterFIFOHandler::l1accept(InDatagram* in)
{
  InDatagram* out = in;
  out->datagram().xtc.extent = sizeof(Xtc);

  do {
    const ClockTime&   iTriggerCounter  = in->seq.clock();
    int                iVector          = 0;

    const EvrDataType* pEvrData         = NULL;
    bool               bOutOfOrder      = false;

    getL1Data(iTriggerCounter, pEvrData, bOutOfOrder);

    if ( bShowFirstFiducial )
      {
        printf("First Fiducial 0x%x prev 0x%x last 0x%x\n",
               in->seq.stamp().fiducials(), uFiducialPrev, _lastFiducial );
        bShowFirstFiducial = false;
      }
    else if ( bShowFiducial )
      printf("Fiducial 0x%x prev 0x%x last 0x%x\n",
             in->seq.stamp().fiducials(), uFiducialPrev, _lastFiducial );

    bool bNoL1Data = ( pEvrData == NULL );
    if ( bNoL1Data ) {
      static const EvrDataType evrDataEmpty( 0, NULL );
      pEvrData = &evrDataEmpty;
    }

    const EvrDataType& evrData = *pEvrData;

    unsigned int  uFiducialCur  = out->datagram().seq.stamp().fiducials();

    if ( _data.getDataReadIncomplete() )
      {
        printf( "MasterFIFOHandler::l1accept(): [%d] Incomplete data with vector %d fiducial 0x%x prev 0x%x last 0x%x\n",
                uNumBeginCalibCycle, iVector, uFiducialCur, uFiducialPrev, _lastFiducial );
        out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);
        out->datagram().xtc.damage.userBits(0x1);

        if ( evrHasEvent(_er) )
          {
            printf( "MasterFIFOHandler::l1accept(): Found unprocessed FIFO event, which may cause missing triggers\n" );
            out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x4);
          }
      }

    if ( uFiducialPrev != 0 && _validateFiducial )
      {
        const int iFiducialWrapAroundDiffMin = 65536;
        if ( (uFiducialCur <= uFiducialPrev && uFiducialPrev < uFiducialCur+iFiducialWrapAroundDiffMin) )
          {
            // !! In burst mode, this is not a error, so we don't set the damage bit, but just print out the information
            printf( "MasterFIFOHandler::l1accept(): seq 0x%x followed 0x%x\n", uFiducialCur, uFiducialPrev );
            //out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);
            //out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x2);
          }
      }

    if ( _data.getDataReadFull() )
      {
        printf( "MasterFIFOHandler::l1accept(): Too many FIFO events recieved, so L1 data buffer is full and incomplete.\n" );
        printf( "  Please check the readout and terminator event settings.\n" );
        out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);
        out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x8);
      }

    if ( bNoL1Data )
      {
        out->datagram().xtc.damage.increase(Pds::Damage::UserDefined);
        out->datagram().xtc.damage.userBits(out->datagram().xtc.damage.userBits() | 0x10);
      }

    /*
     * Set Evr object
     */
    Xtc xtc(TypeId(TypeId::Type(EvrDataType::TypeId),
       uint32_t(EvrDataType::Version)),
      _src);
    xtc.alloc(evrData._sizeof());
    out->insert(xtc, &evrData);

    if ( _validateFiducial && uFiducialCur == 0 && uFiducialPrev < 0x1fe00) { // Likely fiducial corruption
      printf( "MasterFIFOHandler::l1accept(): [%d] vector %d fiducial 0x%x prev 0x%x\n",
              uNumBeginCalibCycle, iVector, uFiducialCur, uFiducialPrev );
      printf( "MasterFIFOHandler::l1accept() data dump start (size = %u bytes)\n", evrData._sizeof() );
      //      evrData.printFifoEvents();
      //      printf( "MasterFIFOHandler::l1accept() data dump end\n\n" );
    }
    //
    //  Test for fiducial mismatch and set outoforder damage
    //

    if (!bNoL1Data && !bOutOfOrder)
      releaseL1Data();

    uFiducialPrev = uFiducialCur;
  }
  while (false);

  //
  //  Special software trigger service to L1 nodes
  //
  _swtrig_out.send(static_cast<CDatagram*>(out), _swtrig_dst);

  return out;
}

bool MasterFIFOHandler::enabled(const FIFOEvent& fe)
{
  //
  //  Some events are trapped in the FIFO sometime around DAQ restart (either shutdown or allocate)
  //  They must be ignored, else they might generate false readout events.
  //
  if ( bEnabled == false )
    {
      printf("MasterFIFOHandler::fifo_event(): [%d] during Disabled, vector %d code %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x.  Dropping\n",
             uNumBeginCalibCycle, _evtCounter, fe.EventCode, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);
      return false;
    }

  if (_validateFiducial && fe.TimestampHigh == 0 && _lastFiducial != 0 && _lastFiducial < 0x1fe00 ) // Possibly illegal fiducial wrap-around
    printf("MasterFIFOHandler::fifo_event(): [%d] fiducial 0 vector %d code %d prev 0x%x last 0x%x (%d) timeLow 0x%x\n",
           uNumBeginCalibCycle, _evtCounter, fe.EventCode, uFiducialPrev, _lastFiducial, _lastFiducial % 3, fe.TimestampLow);
  else {
    if (fe.TimestampHigh != 0 || _lastFiducial >= 0x1fe00 )
      _lastFiducial = fe.TimestampHigh;
  }
  return true;
}

Transition* MasterFIFOHandler::enable      (Transition* tr)
{
  // reset the fiducial checking counter
  uFiducialPrev = 0;
  bShowFirstFiducial  = true;
  bShowFiducial       = false;

  //
  //  Calibration cycle event counting
  //
  const EnableEnv& env = static_cast<const EnableEnv&>(tr->env());
  _evtStop = _evtCounter + env.events();

  if (env.timer())
    {
      _done->set_duration_ms(env.duration());
      _done->start();
    }

  nextEnable(); // clear the unprocessed events from previous Enable-Disable
  bEnabled = true;

  return tr;
}

Transition* MasterFIFOHandler::config      (Transition* tr)
{
  reset();
  uNumBeginCalibCycle = 0;
  return tr;
}

Transition* MasterFIFOHandler::endcalib    (Transition* tr)
{
  ++uNumBeginCalibCycle;
  return tr;
}

void MasterFIFOHandler::fifo_full()
{
  if (!_full) {
    _full = true;
    printf("MasterFIFOHandler FULL\n");
  }
}


void MasterFIFOHandler::startL1Accept(const FIFOEvent& fe, bool bEvrDataIncomplete)
{
  // Warn about possible fiducial corruption (or unlikely fiducial wrap-around)
  if (_validateFiducial && fe.TimestampHigh == 0 && uFiducialPrev < 0x1fe00)
    {
      printf("MasterFIFOHandler::startL1Accept():"
             "[%d] vector 0x%x fiducial 0x%x prev 0x%x Incomplete %c "
             "last 0x%x timeLow 0x%x code %d\n",
             uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, (bEvrDataIncomplete?'Y':'n'),
             _lastFiducial, fe.TimestampLow, fe.EventCode );
    }

  static timespec   tsPrev        = {0,0};
  static unsigned   evtCountPrev  = 0;
  static FIFOEvent  fePrev        = {0,0,0};
  static unsigned   ntsPrints = 10;
  timespec          ts;
  clock_gettime(CLOCK_REALTIME, &ts);

  if(ts.tv_nsec == tsPrev.tv_nsec && ts.tv_sec == tsPrev.tv_sec && fe.TimestampHigh != fePrev.TimestampHigh && ntsPrints!=0) {
    printf("!!! Clocktime duplicated:\n"
           "  Prev clock %09ld.%09ld  evr 0x%x high/low 0x%x/0x%x event %d\n"
           "  Cur  clock %09ld.%09ld  evr 0x%x high/low 0x%x/0x%x event %d\n",
           (long) tsPrev.tv_sec, (long) tsPrev.tv_nsec, evtCountPrev, fePrev.TimestampHigh, fePrev.TimestampLow, fePrev.EventCode,
           (long) ts.tv_sec, (long) ts.tv_nsec, _evtCounter, fe.TimestampHigh, fe.TimestampLow, fe.EventCode
           );
    ntsPrints--;
  }
  tsPrev      = ts;
  evtCountPrev  = _evtCounter;
  fePrev      = fe;

  ClockTime ctime(ts.tv_sec, ts.tv_nsec);
  TimeStamp stamp(fe.TimestampHigh);

  if (_evtCounter == 0)
    {
      _lastTime.tv_nsec = ts.tv_nsec;
      _lastTime.tv_sec = ts.tv_sec;
    }

  if (_state.uMaskReadout == 0) {   // Only commands, no readout
    Sequence seq(Sequence::Occurrence, TransitionId::Unknown, ctime, stamp);
    EvrDatagram datagram(seq, _evtCounter, _state.ncommands);

    //if (_module != 0) {
    //  datagram.evr = _lSegEvtCounter[0];
    //  _outlet.send((char *) &datagram,_state.commands, _state.ncommands, _dst0);
    //}

    for (int iGroup = 0; iGroup < (int) _ldst.size(); ++iGroup) {
      datagram.evr = _lSegEvtCounter[iGroup];
      _outlet.send((char *) &datagram,
                   _state.commands, _state.ncommands, _ldst[iGroup]);
    }
  }
  else {
    Sequence seq(Sequence::Event, TransitionId::L1Accept, ctime, stamp);
    EvrDatagram datagram(seq, _evtCounter++, _state.ncommands);

    if (!_data.isDataWriteReady()) {
      printf( "Previous Evr Data has not been transferred out.\n"
              "  Current data will be reported in next round.\n");
      _print_L1(ctime, _data);
    }
    else
      _state.advance(_data,ctime,bEvrDataIncomplete);

    static const int NEVENTPRINT = 1000;
    if (_evtCounter%NEVENTPRINT == 0)
      {
        clock_gettime(CLOCK_REALTIME, &_thisTime);
        long long int nanoseconds = timeDiff(&_thisTime, &_lastTime);
        float rate = 1000.0 / (nanoseconds * 1.e-9);
        printf("Evr event %d, high/low 0x%05x/0x%x, rate(Hz): %7.2f\n",
               _evtCounter, fe.TimestampHigh, fe.TimestampLow, rate);
        _lastTime.tv_nsec = _thisTime.tv_nsec;
        _lastTime.tv_sec  = _thisTime.tv_sec;
      }

    if (_evtCounter == _evtStop)
      _done->expired();

    /*
     * Send out the L1 "trigger" to make all L1 node start processing.
     *
     * Note: As soon as the send() function is called, the other polling thread may
     *   race with this thread to get the evr data and send it out immediately.
     */

    _srv.post(_lSegEvtCounter[0],datagram.seq.stamp().fiducials());

    _state.uMaskReadout |= 0x1; // Readout group 0 is always triggered
    datagram.setL1AcceptEnv(_state.uMaskReadout);

    //if (_module != 0) {
    //  datagram.evr = _lSegEvtCounter[0];
    //  _outlet.send((char *) &datagram,_state.commands, _state.ncommands, _dst0);
    //}

    unsigned int uGroupBit = 1;
    for (int iGroup = 0; iGroup <= _iMaxGroup; ++iGroup, uGroupBit <<= 1)
      if ( (_state.uMaskReadout & uGroupBit) != 0 ) {
        //printf("sending L1 trigger for group %d\n", iGroup);//!!!debug
        datagram.evr = _lSegEvtCounter[iGroup];
        ++_lSegEvtCounter[iGroup];
        _vmon.readout(iGroup);
        _outlet.send((char *) &datagram,
                     _state.commands, _state.ncommands, _ldst[iGroup]);  //!!! for supporting segment group
      }
  } // else (_uMaskReadout == 0)

  _vmon.update(ctime);
  _state.uMaskReadout  = 0;
  _state.ncommands = 0;
}

void MasterFIFOHandler::clear()
{
  const int iMinCheck =  3;
  const int iMaxCheck = 10;
  int       iCheck    = 0;
  while ( (evrHasEvent(_er) && iCheck < iMaxCheck) || iCheck < iMinCheck )
    { // sleep for 2 millisecond to let signal handler process FIFO events
      timeval timeSleepMicro = {0, 2000}; // 2 milliseconds
      select( 0, NULL, NULL, NULL, &timeSleepMicro);
      iCheck++;
    }

  if (_state.uMaskReadout != 0 || _state.ncommands) {
    FIFOEvent fe;
    fe.TimestampHigh    = _lastFiducial;
    fe.TimestampLow     = 0;
    fe.EventCode        = 0;
    startL1Accept(fe, true);
  }
}

void MasterFIFOHandler::nextEnable()
{
  const int iMaxCheck = 10;
  int       iCheck    = 0;
  while ( evrHasEvent(_er) && ++iCheck <= iMaxCheck ) {
    // sleep for 2 millisecond to let signal handler process FIFO events
    timeval timeSleepMicro = {0, 2000}; // 2 milliseconds
    select( 0, NULL, NULL, NULL, &timeSleepMicro);
  }

  if (_state.uMaskReadout != 0 || _state.ncommands) {
    FIFOEvent fe;
    fe.TimestampHigh    = _lastFiducial;
    fe.TimestampLow     = 0;
    fe.EventCode        = 0;

    printf("MasterFIFOHandler::nextEnable(): [%d] Call startL1Accept() with vector %d fiducial 0x%x prev 0x%x last 0x%x timeLow 0x%x\n",
     uNumBeginCalibCycle, _evtCounter, fe.TimestampHigh, uFiducialPrev, _lastFiducial, fe.TimestampLow);

    startL1Accept(fe, true);
  }
  else
    _data.reset();

  _state.clearFifoEvents();

  /**
   * Note: Don't call _data.reset() to clear the L1 Data buffer here,
   *   because the un-processed L1 Data will be sent out in the Disable action
   */
}

void MasterFIFOHandler::reset()
{
  clear();
  _data.reset();
  _evtCounter = 0;
  _lSegEvtCounter.assign(_lSegEvtCounter.size(), 0);
  _full = false;
  _vmon.reset();
}

int MasterFIFOHandler::getL1Data(const ClockTime& iTriggerCounter, const EvrDataType* & pEvrData, bool& bOutOfOrder)
{
  pEvrData    = NULL; // default return value: invalid data
  bOutOfOrder = false;

  if ( ! _data.isDataReadReady() )
    {
      printf( "MasterFIFOHandler::getL1Data(): No L1 Data ready: ");
      _print_L1(iTriggerCounter,_data);
      return 1; // Will set Dropped Contribution damage for L1 Data
    }

  /*
   * Normal case: current data counter == trigger counter
   */
  if ( _data.getCounterRead() == iTriggerCounter )
    {
      pEvrData = (const EvrDataType*)_data.getDataRead();
      return 0;
    }

  /*
   * Error cases:
   *
   * Case 1: Current data counter is later than the trigger counter
   *
   *   In this case, we will do nothing to the existing data
   *   We just return an error code to indicate
   *   thre is no valid L1 data returned
   */

  if ( _data.getCounterRead() > iTriggerCounter ) //  test if data is later than trigger
    {
      printf( "MasterFIFOHandler::getL1Data(): Missing L1 Data: ");
      _print_L1(iTriggerCounter,_data);
      return 2;
    }

  /*
   * Case 2: Current data counter is earlier than trigger counter
   *
   *   We test if there exists a data that has the same counter as the trigger
   */
  int iDataIndex =  _data.findDataWithCounter( iTriggerCounter );
  if ( iDataIndex != -1 )
    {
      /*
       * Case 2a: Some out-of-order data matches the trigger
       *
       *   In this case, we will return corresponding data,
       *   and mark this data as invalid, so it will not be
       *   used later
       */
      printf( "MasterFIFOHandler::getL1Data(): Recovered Out-of-order L1 Data: Data Index = %d, ",iDataIndex);
      _print_L1(iTriggerCounter, _data);

      _data.markDataAsInvalid( iDataIndex );
      pEvrData = (const EvrDataType*) _data.getDataWithIndex( iDataIndex );

      /*
       *   We return a special error code to indicate that
       *   the data is an out-of-order data, so the buffer
       *   should not be released by client, until all earlier
       *   data have been processed
       */
      bOutOfOrder = true;
      return 3;
    }


  /*
   * Case 2b: No data in the buffer can match the trigger
   *
   *   In this case, we will discard the data until the remaining
   *   data is newer than the trigger
   *
   *   Then we return an error code to
   *   indicate thre is no valid L1 data returned
   */

  printf( "MasterFIFOHandler::getL1Data(): Missing Triggers: ");
  _print_L1(iTriggerCounter, _data);

  int iDataDropped = 0;
  while (
         _data.isDataReadReady() &&
         ( iTriggerCounter > _data.getCounterRead() ) // test if trigger is later than data
         )
    {
      ++iDataDropped;
      _data.finishDataRead();
    }

  printf("MasterFIFOHandler::getL1Data(): Dropped %d Data: ", iDataDropped);
  _print_L1(iTriggerCounter, _data);
  return 4; // Will set Dropped Contribution damage for L1 Data
}

void MasterFIFOHandler::releaseL1Data()
{
  /*
   * For the first time setup:
   *
   * Set signal mask so that this thread will not be used
   * as evr's signal handler
   */
  static bool bThreadSyncInit = false;
  if (!bThreadSyncInit)
    {
      sigset_t sigetHoldIO;
      sigemptyset(&sigetHoldIO);
      sigaddset  (&sigetHoldIO, SIGIO);

      if ( pthread_sigmask(SIG_BLOCK, &sigetHoldIO, NULL) < 0 )
        perror( "MasterFIFOHandler::releaseL1Data(): pthread_sigmask() failed" );

      bThreadSyncInit = true;
    }

  _data.finishDataRead();
}

// check if evr has any unprocessed fifo event
bool evrHasEvent(Evr& er)
{
  uint32_t& uIrqFlagOrg = *(uint32_t*) ((char*) &er + 8);
  uint32_t  uIrqFlagNew = be32_to_cpu(uIrqFlagOrg);

  if ( uIrqFlagNew & EVR_IRQFLAG_EVENT)
    return true;
  else
    return false;
}

void MasterFIFOHandler::release_sync()
{
  bShowFirstFiducial  = false;
  bShowFiducial       = true;

  _done->cancel();

  clear();

  bEnabled = false;
}

void MasterFIFOHandler::set_config  (const EvrConfigType* pEvrConfig)
{
  _state.configure( pEvrConfig->eventcodes() );
}

void MasterFIFOHandler::validateFiducial(bool v)
{ _validateFiducial=v; }
